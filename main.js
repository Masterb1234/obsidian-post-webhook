/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/webhookService.js
var require_webhookService = __commonJS({
  "src/webhookService.js"(exports2, module2) {
    var { requestUrl: requestUrl2, arrayBufferToBase64, parseYaml, getFrontMatterInfo } = require("obsidian");
    var WebhookService2 = class {
      static validateUrl(url) {
        try {
          const parsedUrl = new URL(url);
          return parsedUrl.protocol === "http:" || parsedUrl.protocol === "https:";
        } catch (e) {
          return false;
        }
      }
      static parseYamlFrontmatter(content) {
        const info = getFrontMatterInfo(content);
        if (!info.exists) {
          return {
            frontmatter: {},
            content
          };
        }
        const frontmatter = parseYaml(info.frontmatter);
        const contentWithoutFrontmatter = content.slice(info.contentStart);
        return {
          frontmatter,
          content: contentWithoutFrontmatter
        };
      }
      static async getAttachments(app, file) {
        const attachments = [];
        const cache = app.metadataCache.getFileCache(file);
        if (!cache) {
          return attachments;
        }
        const processFile = async (linkedFile) => {
          if (linkedFile && !linkedFile.children) {
            const buffer = await app.vault.readBinary(linkedFile);
            const base64 = arrayBufferToBase64(buffer);
            const mimeType = this.getMimeType(linkedFile.extension);
            attachments.push({
              name: linkedFile.name,
              type: linkedFile.extension,
              mimeType,
              size: buffer.byteLength,
              data: `data:${mimeType};base64,${base64}`,
              path: linkedFile.path
            });
          }
        };
        if (cache.embeds) {
          for (const embed of cache.embeds) {
            if (embed.link) {
              const linkedFile = app.metadataCache.getFirstLinkpathDest(embed.link, file.path);
              if (linkedFile) {
                await processFile(linkedFile);
              }
            }
          }
        }
        if (cache.links) {
          for (const link of cache.links) {
            if (link.link) {
              const linkedFile = app.metadataCache.getFirstLinkpathDest(link.link, file.path);
              if (linkedFile) {
                await processFile(linkedFile);
              }
            }
          }
        }
        return attachments;
      }
      static getMimeType(extension) {
        const mimeTypes = {
          png: "image/png",
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          gif: "image/gif",
          webp: "image/webp",
          svg: "image/svg+xml",
          mp3: "audio/mpeg",
          wav: "audio/wav",
          ogg: "audio/ogg",
          m4a: "audio/mp4",
          mp4: "video/mp4",
          webm: "video/webm",
          ogv: "video/ogg",
          mov: "video/quicktime",
          pdf: "application/pdf",
          doc: "application/msword",
          docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          json: "application/json",
          xml: "application/xml",
          zip: "application/zip"
        };
        return mimeTypes[extension == null ? void 0 : extension.toLowerCase()] || "application/octet-stream";
      }
      static async sendContent(app, webhookUrl, content, filename, file) {
        if (!webhookUrl) {
          throw new Error("Webhook URL is required");
        }
        if (!this.validateUrl(webhookUrl)) {
          throw new Error("Invalid Webhook URL. Must be a valid HTTP or HTTPS URL");
        }
        try {
          const info = getFrontMatterInfo(content);
          const attachments = await this.getAttachments(app, file);
          let payload;
          if (info.exists) {
            const frontmatter = parseYaml(info.frontmatter);
            const noteContent = content.slice(info.contentStart).trim();
            payload = {
              ...frontmatter,
              // This puts all YAML fields at root level
              content: noteContent,
              filename,
              timestamp: Date.now(),
              attachments
            };
          } else {
            payload = {
              content,
              filename,
              timestamp: Date.now(),
              attachments
            };
          }
          const response = await requestUrl2({
            url: webhookUrl,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            body: JSON.stringify(payload)
          });
          if (response.status >= 400) {
            throw new Error(`Request failed: ${response.status}`);
          }
          return response;
        } catch (error) {
          if (error.message.includes("Failed to fetch")) {
            throw new Error("Could not connect to the Webhook URL. Please check your internet connection and the URL");
          }
          throw new Error(`Failed to send Webhook: ${error.message}`);
        }
      }
      static async testWebhook(webhookUrl) {
        if (!this.validateUrl(webhookUrl)) {
          throw new Error("Invalid Webhook URL. Must be a valid HTTP or HTTPS URL");
        }
        try {
          const testPayload = {
            test: true,
            timestamp: Date.now(),
            message: "This is a test message from Post Webhook plugin"
          };
          const response = await requestUrl2({
            url: webhookUrl,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
            },
            body: JSON.stringify(testPayload)
          });
          if (response.status >= 400) {
            throw new Error(`Test request failed with status: ${response.status}`);
          }
          return {
            success: true,
            message: "Webhook test successful!"
          };
        } catch (error) {
          return {
            success: false,
            message: `Webhook test failed: ${error.message}`
          };
        }
      }
    };
    module2.exports = WebhookService2;
  }
});

// src/main.js
var { Plugin, Notice, PluginSettingTab, Setting, requestUrl } = require("obsidian");
var WebhookService = require_webhookService();
var PostWebhookPlugin = class extends Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "send-to-webhook",
      name: "Send to Webhook",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new Notice("No active file");
          return;
        }
        if (!this.settings.webhookUrl) {
          new Notice("Please configure Webhook URL in settings");
          return;
        }
        try {
          const content = await this.app.vault.read(file);
          const response = await WebhookService.sendContent(this.app, this.settings.webhookUrl, content, file.name, file);
          if (this.settings.attachResponse && response.text) {
            const responseContent = `

---
${response.text}`;
            const newContent = content + responseContent;
            await this.app.vault.modify(file, newContent);
          }
          new Notice("Successfully sent to Webhook");
        } catch (error) {
          console.error("Webhook error:", error);
          new Notice(`Error: ${error.message}`);
        }
      }
    });
    this.addSettingTab(new PostWebhookSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, {
      webhookUrl: "",
      attachResponse: false
    }, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var PostWebhookSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new Setting(containerEl).setName("Webhook URL").setDesc("Enter the URL where your notes will be sent").addText((text) => text.setPlaceholder("https://your-webhook-url").setValue(this.plugin.settings.webhookUrl).onChange(async (value) => {
      this.plugin.settings.webhookUrl = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("Attach Response").setDesc("Append Webhook response to the note").addToggle((toggle) => toggle.setValue(this.plugin.settings.attachResponse).onChange(async (value) => {
      this.plugin.settings.attachResponse = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("Test Webhook").setDesc("Send a test request to verify your Webhook configuration").addButton((button) => button.setButtonText("Test Webhook").onClick(async () => {
      if (!this.plugin.settings.webhookUrl) {
        new Notice("Please configure Webhook URL first");
        return;
      }
      try {
        const testPayload = {
          test: true,
          timestamp: Date.now(),
          message: "Test Webhook from Obsidian"
        };
        const response = await requestUrl({
          url: this.plugin.settings.webhookUrl,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          body: JSON.stringify(testPayload)
        });
        if (response.status < 400) {
          new Notice("Test Webhook sent successfully");
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error) {
        new Notice(`Test failed: ${error.message}`);
      }
    }));
  }
};
module.exports = PostWebhookPlugin;
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL3dlYmhvb2tTZXJ2aWNlLmpzIiwgInNyYy9tYWluLmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJjb25zdCB7IHJlcXVlc3RVcmwsIGFycmF5QnVmZmVyVG9CYXNlNjQsIHBhcnNlWWFtbCwgZ2V0RnJvbnRNYXR0ZXJJbmZvIH0gPSByZXF1aXJlKCdvYnNpZGlhbicpO1xuXG5jbGFzcyBXZWJob29rU2VydmljZSB7XG4gICAgc3RhdGljIHZhbGlkYXRlVXJsKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6JyB8fCBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVlhbWxGcm9udG1hdHRlcihjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBnZXRGcm9udE1hdHRlckluZm8oY29udGVudCk7XG4gICAgICAgIGlmICghaW5mby5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbnRtYXR0ZXI6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBwYXJzZVlhbWwoaW5mby5mcm9udG1hdHRlcik7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRXaXRob3V0RnJvbnRtYXR0ZXIgPSBjb250ZW50LnNsaWNlKGluZm8uY29udGVudFN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb250bWF0dGVyLFxuICAgICAgICAgICAgY29udGVudDogY29udGVudFdpdGhvdXRGcm9udG1hdHRlclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBnZXRBdHRhY2htZW50cyhhcHAsIGZpbGUpIHtcbiAgICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXR0YWNobWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9jZXNzRmlsZSA9IGFzeW5jIChsaW5rZWRGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlua2VkRmlsZSAmJiAhbGlua2VkRmlsZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGFwcC52YXVsdC5yZWFkQmluYXJ5KGxpbmtlZEZpbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMuZ2V0TWltZVR5cGUobGlua2VkRmlsZS5leHRlbnNpb24pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsaW5rZWRGaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGxpbmtlZEZpbGUuZXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHtiYXNlNjR9YCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbGlua2VkRmlsZS5wYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNhY2hlLmVtYmVkcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbWJlZCBvZiBjYWNoZS5lbWJlZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1iZWQubGluaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rZWRGaWxlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZW1iZWQubGluaywgZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmtlZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NGaWxlKGxpbmtlZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlLmxpbmtzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgY2FjaGUubGlua3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluay5saW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtlZEZpbGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChsaW5rLmxpbmssIGZpbGUucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rZWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwcm9jZXNzRmlsZShsaW5rZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhdHRhY2htZW50cztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWltZVR5cGUoZXh0ZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlcyA9IHtcbiAgICAgICAgICAgIHBuZzogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgICBqcGc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgIGpwZWc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgIGdpZjogJ2ltYWdlL2dpZicsXG4gICAgICAgICAgICB3ZWJwOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICBzdmc6ICdpbWFnZS9zdmcreG1sJyxcbiAgICAgICAgICAgIG1wMzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAgICAgd2F2OiAnYXVkaW8vd2F2JyxcbiAgICAgICAgICAgIG9nZzogJ2F1ZGlvL29nZycsXG4gICAgICAgICAgICBtNGE6ICdhdWRpby9tcDQnLFxuICAgICAgICAgICAgbXA0OiAndmlkZW8vbXA0JyxcbiAgICAgICAgICAgIHdlYm06ICd2aWRlby93ZWJtJyxcbiAgICAgICAgICAgIG9ndjogJ3ZpZGVvL29nZycsXG4gICAgICAgICAgICBtb3Y6ICd2aWRlby9xdWlja3RpbWUnLFxuICAgICAgICAgICAgcGRmOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgICAgIGRvYzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gICAgICAgICAgICBkb2N4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgIHppcDogJ2FwcGxpY2F0aW9uL3ppcCdcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBtaW1lVHlwZXNbZXh0ZW5zaW9uPy50b0xvd2VyQ2FzZSgpXSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgc2VuZENvbnRlbnQoYXBwLCB3ZWJob29rVXJsLCBjb250ZW50LCBmaWxlbmFtZSwgZmlsZSkge1xuICAgICAgICBpZiAoIXdlYmhvb2tVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViaG9vayBVUkwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVVybCh3ZWJob29rVXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdlYmhvb2sgVVJMLiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gZ2V0RnJvbnRNYXR0ZXJJbmZvKGNvbnRlbnQpO1xuICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBhd2FpdCB0aGlzLmdldEF0dGFjaG1lbnRzKGFwcCwgZmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBwYXlsb2FkO1xuICAgICAgICAgICAgaWYgKGluZm8uZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgPSBwYXJzZVlhbWwoaW5mby5mcm9udG1hdHRlcik7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90ZUNvbnRlbnQgPSBjb250ZW50LnNsaWNlKGluZm8uY29udGVudFN0YXJ0KS50cmltKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnJvbnRtYXR0ZXIsICAvLyBUaGlzIHB1dHMgYWxsIFlBTUwgZmllbGRzIGF0IHJvb3QgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogbm90ZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICAgICAgICAgICAgICB1cmw6IHdlYmhvb2tVcmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIFdlYmhvb2sgVVJMLiBQbGVhc2UgY2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uIGFuZCB0aGUgVVJMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZW5kIFdlYmhvb2s6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyB0ZXN0V2ViaG9vayh3ZWJob29rVXJsKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVVybCh3ZWJob29rVXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdlYmhvb2sgVVJMLiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBpcyBhIHRlc3QgbWVzc2FnZSBmcm9tIFBvc3QgV2ViaG9vayBwbHVnaW4nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgICAgIHVybDogd2ViaG9va1VybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRlc3RQYXlsb2FkKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXN0IHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdXZWJob29rIHRlc3Qgc3VjY2Vzc2Z1bCEnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgV2ViaG9vayB0ZXN0IGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViaG9va1NlcnZpY2U7IiwgImNvbnN0IHsgUGx1Z2luLCBOb3RpY2UsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIHJlcXVlc3RVcmwgfSA9IHJlcXVpcmUoJ29ic2lkaWFuJyk7XG5jb25zdCBXZWJob29rU2VydmljZSA9IHJlcXVpcmUoJy4vd2ViaG9va1NlcnZpY2UnKTtcblxuY2xhc3MgUG9zdFdlYmhvb2tQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdzZW5kLXRvLXdlYmhvb2snLFxuICAgICAgICAgICAgbmFtZTogJ1NlbmQgdG8gV2ViaG9vaycsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdObyBhY3RpdmUgZmlsZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLndlYmhvb2tVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIGNvbmZpZ3VyZSBXZWJob29rIFVSTCBpbiBzZXR0aW5ncycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgV2ViaG9va1NlcnZpY2Uuc2VuZENvbnRlbnQodGhpcy5hcHAsIHRoaXMuc2V0dGluZ3Mud2ViaG9va1VybCwgY29udGVudCwgZmlsZS5uYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmF0dGFjaFJlc3BvbnNlICYmIHJlc3BvbnNlLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudCA9IGBcXG5cXG4tLS1cXG4ke3Jlc3BvbnNlLnRleHR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBjb250ZW50ICsgcmVzcG9uc2VDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGZpbGUsIG5ld0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdTdWNjZXNzZnVsbHkgc2VudCB0byBXZWJob29rJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2ViaG9vayBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFBvc3RXZWJob29rU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIHdlYmhvb2tVcmw6ICcnLFxuICAgICAgICAgICAgYXR0YWNoUmVzcG9uc2U6IGZhbHNlXG4gICAgICAgIH0sIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cbn1cblxuY2xhc3MgUG9zdFdlYmhvb2tTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBwbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1dlYmhvb2sgVVJMJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdFbnRlciB0aGUgVVJMIHdoZXJlIHlvdXIgbm90ZXMgd2lsbCBiZSBzZW50JylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignaHR0cHM6Ly95b3VyLXdlYmhvb2stdXJsJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mud2ViaG9va1VybClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLndlYmhvb2tVcmwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0F0dGFjaCBSZXNwb25zZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnQXBwZW5kIFdlYmhvb2sgcmVzcG9uc2UgdG8gdGhlIG5vdGUnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF0dGFjaFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXR0YWNoUmVzcG9uc2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1Rlc3QgV2ViaG9vaycpXG4gICAgICAgICAgICAuc2V0RGVzYygnU2VuZCBhIHRlc3QgcmVxdWVzdCB0byB2ZXJpZnkgeW91ciBXZWJob29rIGNvbmZpZ3VyYXRpb24nKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1Rlc3QgV2ViaG9vaycpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLndlYmhvb2tVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1BsZWFzZSBjb25maWd1cmUgV2ViaG9vayBVUkwgZmlyc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGVzdCBXZWJob29rIGZyb20gT2JzaWRpYW4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5wbHVnaW4uc2V0dGluZ3Mud2ViaG9va1VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRlc3RQYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdUZXN0IFdlYmhvb2sgc2VudCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgVGVzdCBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9zdFdlYmhvb2tQbHVnaW47Il0s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QSxFQUNyQztBQUNKO0FBRUEsSUFBTSx3QkFBTixjQUFvQyxpQkFBaUI7QUFBQSxFQUNqRCxZQUFZLEtBQUssUUFBUTtBQUNyQixVQUFNLEtBQUssTUFBTTtBQUNqQixTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBRUEsVUFBVTtBQUNOLFVBQU0sRUFBRSxZQUFZLElBQUk7QUFDeEIsZ0JBQVksTUFBTTtBQUVsQixRQUFJLFFBQVEsV0FBVyxFQUNsQixRQUFRLGFBQWEsRUFDckIsUUFBUSw2Q0FBNkMsRUFDckQsUUFBUSxVQUFRLEtBQ1osZUFBZSwwQkFBMEIsRUFDekMsU0FBUyxLQUFLLE9BQU8sU0FBUyxVQUFVLEVBQ3hDLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFdBQUssT0FBTyxTQUFTLGFBQWE7QUFDbEMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ25DLENBQUMsQ0FBQztBQUVWLFFBQUksUUFBUSxXQUFXLEVBQ2xCLFFBQVEsaUJBQWlCLEVBQ3pCLFFBQVEscUNBQXFDLEVBQzdDLFVBQVUsWUFBVSxPQUNoQixTQUFTLEtBQUssT0FBTyxTQUFTLGNBQWMsRUFDNUMsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsaUJBQWlCO0FBQ3RDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFFVixRQUFJLFFBQVEsV0FBVyxFQUNsQixRQUFRLGNBQWMsRUFDdEIsUUFBUSwwREFBMEQsRUFDbEUsVUFBVSxZQUFVLE9BQ2hCLGNBQWMsY0FBYyxFQUM1QixRQUFRLFlBQVk7QUFDakIsVUFBSSxDQUFDLEtBQUssT0FBTyxTQUFTLFlBQVk7QUFDbEMsWUFBSSxPQUFPLG9DQUFvQztBQUMvQztBQUFBLE1BQ0o7QUFFQSxVQUFJO0FBQ0EsY0FBTSxjQUFjO0FBQUEsVUFDaEIsTUFBTTtBQUFBLFVBQ04sV0FBVyxLQUFLLElBQUk7QUFBQSxVQUNwQixTQUFTO0FBQUEsUUFDYjtBQUVBLGNBQU0sV0FBVyxNQUFNLFdBQVc7QUFBQSxVQUM5QixLQUFLLEtBQUssT0FBTyxTQUFTO0FBQUEsVUFDMUIsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFlBQ0wsZ0JBQWdCO0FBQUEsWUFDaEIsVUFBVTtBQUFBLFVBQ2Q7QUFBQSxVQUNBLE1BQU0sS0FBSyxVQUFVLFdBQVc7QUFBQSxRQUNwQyxDQUFDO0FBRUQsWUFBSSxTQUFTLFNBQVMsS0FBSztBQUN2QixjQUFJLE9BQU8sZ0NBQWdDO0FBQUEsUUFDL0MsT0FBTztBQUNILGdCQUFNLElBQUksTUFBTSxRQUFRLFNBQVMsUUFBUTtBQUFBLFFBQzdDO0FBQUEsTUFDSixTQUFTLE9BQVA7QUFDRSxZQUFJLE9BQU8sZ0JBQWdCLE1BQU0sU0FBUztBQUFBLE1BQzlDO0FBQUEsSUFDSixDQUFDLENBQUM7QUFBQSxFQUNkO0FBQ0o7QUFFQSxPQUFPLFVBQVU7IiwKICAibmFtZXMiOiBbImV4cG9ydHMiLCAibW9kdWxlIiwgInJlcXVlc3RVcmwiLCAiV2ViaG9va1NlcnZpY2UiXQp9Cg==
